<!DOCTYPE html>
<html>
<head>
    <title>Chess AI</title>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chess.js@0.10.3/chess.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">
    <script src="https://cdn.jsdelivr.net/npm/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
    <style>
        body { font-family: sans-serif; max-width: 500px; margin: 0 auto; }
        #board { 
            margin: 20px auto; 
            width: 400px;
            z-index: 0;
        }
        .controls { text-align: center; margin: 20px; }
        button { padding: 10px 20px; font-size: 16px; margin: 0 10px; }
        #status { min-height: 24px; margin: 10px; font-weight: bold; }
    </style>
</head>
<body>
    <h1>Chess AI (Dataset-Powered)</h1>
    <div id="board"></div>
    <div class="controls">
        <button id="reset">New Game</button>
        <button id="undo">Undo</button>
        <div id="status"></div>
    </div>

    <script>
        // Initialize chess.js game
        const game = new Chess();
        let moveHistory = [];
        
        // Initialize chessboard with proper settings
        const board = Chessboard('board', {
            position: 'start',
            pieceTheme: '/chess-pieces/{piece}.png',
            draggable: true,
            appearSpeed: 100,
            moveSpeed: 200,
            onDragStart: onDragStart,
            onDrop: onDrop,
            snapbackSpeed: 100,
            snapSpeed: 50
        });

        // Update game status display
        function updateStatus() {
            let status = '';
            if (game.isCheckmate()) {
                status = 'Checkmate - ' + (game.turn() === 'w' ? 'Black wins!' : 'White wins!');
            } 
            else if (game.isDraw()) {
                status = 'Draw - ' + (
                    game.isThreefoldRepetition() ? 'Threefold repetition' :
                    game.isStalemate() ? 'Stalemate' :
                    game.isInsufficientMaterial() ? 'Insufficient material' :
                    '50-move rule'
                );
            }
            else {
                status = game.turn() === 'w' ? 'Your turn (White)' : 'AI thinking (Black)...';
                if (game.inCheck()) status += ' (Check!)';
            }
            $('#status').text(status);
        }

        // Validate piece movement
        function onDragStart(source, piece, position, orientation) {
            // Only allow player (white) to move during their turn
            if (game.game_over() || 
                !piece.startsWith('w') || 
                game.turn() !== 'w') {
                return false;
            }
            
            // Highlight legal moves (optional visual feedback)
            highlightLegalMoves(source);
            return true;
        }

        // Handle piece drops
        function onDrop(source, target) {
            // Remove any move highlights
            removeHighlights();
            
            // Try to make the move
            const move = game.move({
                from: source,
                to: target,
                promotion: 'q' // Auto-queen on promotion
            });
            
            // Illegal move
            if (move === null) {
                return 'snapback';
            }
            
            // Legal move - update game state
            moveHistory.push(game.fen());
            board.position(game.fen());
            updateStatus();
            
            // AI move if game continues
            if (!game.game_over()) {
                setTimeout(makeAIMove, 500);
            }
            
            return true;
        }

        // AI move logic
        function makeAIMove() {
            // Simple AI: random legal move
            const moves = game.moves({verbose: true});
            if (moves.length > 0) {
                const move = moves[Math.floor(Math.random() * moves.length)];
                game.move(move);
                board.position(game.fen());
                moveHistory.push(game.fen());
                updateStatus();
            }
        }

        // Highlight legal moves (visual feedback)
        function highlightLegalMoves(source) {
            const moves = game.moves({
                square: source,
                verbose: true
            });
            
            moves.forEach(move => {
                $(`#board .square-${move.to}`).addClass('highlight');
            });
            
            // Add CSS for highlights
            $('<style>').text(`
                .highlight {
                    background-color: rgba(0, 255, 0, 0.4) !important;
                }
            `).appendTo('head');
        }

        // Remove move highlights
        function removeHighlights() {
            $('.highlight').removeClass('highlight');
        }

        // Reset game
        $('#reset').click(() => {
            game.reset();
            board.position('start');
            moveHistory = [];
            removeHighlights();
            updateStatus();
        });

        // Undo move
        $('#undo').click(() => {
            if (moveHistory.length > 1) {
                moveHistory.pop(); // Remove current state
                const prevState = moveHistory.pop() || 'start';
                game.load(prevState);
                board.position(prevState);
                updateStatus();
            }
        });

        // Initialize game
        updateStatus();
    </script>
</body>
</html>
