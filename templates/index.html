<!DOCTYPE html>
<html>
<head>
    <title>Chess AI</title>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chess.js@0.10.3/chess.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">
    <script src="https://cdn.jsdelivr.net/npm/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
    <style>
        body { 
            font-family: sans-serif; 
            max-width: 500px; 
            margin: 0 auto; 
            text-align: center;
        }
        #board { 
            margin: 20px auto; 
            width: 400px;
            z-index: 0;
        }
        .controls { 
            text-align: center; 
            margin: 20px; 
        }
        button { 
            padding: 10px 20px; 
            font-size: 16px; 
            margin: 0 10px; 
            cursor: pointer;
        }
        #status { 
            min-height: 24px; 
            margin: 10px; 
            font-weight: bold; 
            font-size: 18px;
        }
        .color-selection {
            margin: 20px;
            padding: 20px;
            border: 1px solid #ccc;
            border-radius: 5px;
            background: #f9f9f9;
        }
        .color-btn {
            padding: 15px 30px;
            font-size: 18px;
            margin: 10px;
        }
        .highlight {
            background-color: rgba(0, 255, 0, 0.4) !important;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <h1>Chess AI</h1>
    
    <div id="color-selection" class="color-selection">
        <h2>Choose Your Color</h2>
        <button id="play-white" class="color-btn">Play as White (First Move)</button>
        <button id="play-black" class="color-btn">Play as Black (AI Moves First)</button>
    </div>
    
    <div id="game-container" class="hidden">
        <div id="board"></div>
        <div class="controls">
            <button id="reset">New Game</button>
            <button id="undo">Undo</button>
            <div id="status"></div>
        </div>
    </div>

    <script>
        // Game state variables
        const game = new Chess();
        let moveHistory = [];
        let playerColor = 'w';
        let board;
        
        // DOM elements
        const colorSelection = $('#color-selection');
        const gameContainer = $('#game-container');
        const playWhiteBtn = $('#play-white');
        const playBlackBtn = $('#play-black');
        
        // Initialize the game when color is selected
        playWhiteBtn.click(() => startGame('w'));
        playBlackBtn.click(() => startGame('b'));
        
        function startGame(color) {
            playerColor = color;
            colorSelection.addClass('hidden');
            gameContainer.removeClass('hidden');
            
            // Initialize chessboard
            board = Chessboard('board', {
                position: 'start',
                pieceTheme: '/chess-pieces/{piece}.png',
                draggable: true,
                appearSpeed: 100,
                moveSpeed: 200,
                onDragStart: onDragStart,
                onDrop: onDrop,
                snapbackSpeed: 100,
                snapSpeed: 50,
                orientation: color === 'w' ? 'white' : 'black',
                onSnapEnd: onSnapEnd  // Added to handle piece unselection
            });
            
            game.reset();
            moveHistory = [game.fen()];
            updateStatus();
            
            // If player chose black, let AI make first move
            if (playerColor === 'b') {
                setTimeout(makeAIMove, 500);
            }
        }
        
        // Handle piece unselection after move
        function onSnapEnd() {
            board.position(game.fen());
        }
        
        // Update game status display
        function updateStatus() {
            let status = '';
            if (game.isCheckmate()) {
                status = 'Checkmate - ' + (game.turn() === 'w' ? 'Black wins!' : 'White wins!');
            } 
            else if (game.isDraw()) {
                status = 'Draw - ' + (
                    game.isThreefoldRepetition() ? 'Threefold repetition' :
                    game.isStalemate() ? 'Stalemate' :
                    game.isInsufficientMaterial() ? 'Insufficient material' :
                    '50-move rule'
                );
            }
            else {
                const currentTurn = game.turn();
                const isPlayerTurn = currentTurn === playerColor;
                const colorName = playerColor === 'w' ? 'White' : 'Black';
                const aiColorName = playerColor === 'w' ? 'Black' : 'White';
                
                status = isPlayerTurn ? `Your turn (${colorName})` : `${aiColorName} AI is thinking...`;
                if (game.inCheck()) status += ' (Check!)';
            }
            $('#status').text(status);
        }
        
        // Validate piece movement
        function onDragStart(source, piece, position, orientation) {
            // Only allow player to move their pieces during their turn
            if (game.game_over() || 
                !piece.startsWith(playerColor) || 
                game.turn() !== playerColor) {
                return false;
            }
            
            // Highlight legal moves
            highlightLegalMoves(source);
            return true;
        }
        
        // Handle piece drops
        function onDrop(source, target) {
            // Remove any move highlights
            removeHighlights();
            
            // Try to make the move
            const move = game.move({
                from: source,
                to: target,
                promotion: 'q' // Auto-queen on promotion
            });
            
            // Illegal move
            if (move === null) {
                return 'snapback';
            }
            
            // Legal move - update game state
            moveHistory.push(game.fen());
            updateStatus();
            
            // Return true to accept the move
            // The actual position update will happen in onSnapEnd
            return true;
        }
        
        // AI move logic (improved with basic piece values)
        function makeAIMove() {
            if (game.game_over()) return;
            
            const moves = game.moves({verbose: true});
            if (moves.length === 0) return;
            
            // Simple evaluation function
            const evaluateMove = (move) => {
                let score = 0;
                
                // Piece values
                const pieceValues = { p: 1, n: 3, b: 3, r: 5, q: 9, k: 0 };
                
                // Capture opponent pieces
                if (move.captured) {
                    score += pieceValues[move.captured] * 10;
                }
                
                // Promote pawns
                if (move.promotion) {
                    score += pieceValues[move.promotion] * 5;
                }
                
                // Check
                if (move.san.includes('+')) {
                    score += 2;
                }
                
                // Randomness to make less predictable
                score += Math.random();
                
                return score;
            };
            
            // Find best move based on simple evaluation
            let bestMove = moves[0];
            let bestScore = evaluateMove(moves[0]);
            
            for (let i = 1; i < moves.length; i++) {
                const score = evaluateMove(moves[i]);
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = moves[i];
                }
            }
            
            // Make the move
            game.move(bestMove);
            moveHistory.push(game.fen());
            board.position(game.fen());
            updateStatus();
        }
        
        // Highlight legal moves
        function highlightLegalMoves(source) {
            const moves = game.moves({
                square: source,
                verbose: true
            });
            
            moves.forEach(move => {
                $(`#board .square-${move.to}`).addClass('highlight');
            });
        }
        
        // Remove move highlights
        function removeHighlights() {
            $('.highlight').removeClass('highlight');
        }
        
        // Reset game
        $('#reset').click(() => {
            colorSelection.removeClass('hidden');
            gameContainer.addClass('hidden');
            if (board) {
                board.destroy();
            }
        });
        
        // Undo move
        $('#undo').click(() => {
            if (moveHistory.length > 1) {
                moveHistory.pop(); // Remove current state
                const prevState = moveHistory.pop() || 'start';
                game.load(prevState);
                board.position(prevState);
                updateStatus();
            }
        });
    </script>
</body>
</html>
